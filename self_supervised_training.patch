diff --git a/src/statement_refinery/validation.py b/src/statement_refinery/validation.py
index 1234567..abcdefg 100644
--- a/src/statement_refinery/validation.py
+++ b/src/statement_refinery/validation.py
@@ -8,15 +8,28 @@ from pathlib import Path
 from typing import Any, Dict, Iterable, List, Tuple
 
 __all__ = [
     "extract_total_from_pdf",
+    "extract_statement_totals", 
     "calculate_csv_total",
+    "calculate_category_totals",
+    "calculate_fitness_score",
     "find_duplicates",
     "validate_categories",
     "analyze_rows",
 ]
 
+# Category mappings for fitness calculation
+DOMESTIC_CATEGORIES = {
+    "SUPERMERCADO", "FARMÁCIA", "RESTAURANTE", "POSTO", "TRANSPORTE", 
+    "ALIMENTAÇÃO", "SAÚDE", "VEÍCULOS", "VESTUÁRIO", "EDUCAÇÃO", "HOBBY"
+}
+
+INTERNATIONAL_CATEGORIES = {"FX", "INTERNACIONAL"}
+
+SERVICE_CATEGORIES = {"SERVIÇOS", "ENCARGOS"}
+
 
 def extract_total_from_pdf(pdf_path: Path) -> Decimal:
     """Return the total amount printed in *pdf_path* or its ``.txt`` snapshot."""
     txt_path = pdf_path.with_suffix(".txt")
@@ -47,6 +60,73 @@ def extract_total_from_pdf(pdf_path: Path) -> Decimal:
     raise ValueError(f"Could not find total in {pdf_path.name}")
 
 
+def extract_statement_totals(pdf_path: Path) -> Dict[str, Decimal]:
+    """Extract all financial totals from PDF statement summary for self-supervised training."""
+    txt_path = pdf_path.with_suffix(".txt")
+    if txt_path.exists():
+        text = txt_path.read_text(encoding="utf-8")
+    else:
+        try:
+            import pdfplumber  # type: ignore
+        except Exception as exc:
+            raise FileNotFoundError(f"No text fallback for {pdf_path.name}") from exc
+        with pdfplumber.open(str(pdf_path)) as pdf:
+            text = "\n".join(page.extract_text() or "" for page in pdf.pages)
+        txt_path.write_text(text, encoding="utf-8")
+
+    # Enhanced patterns for multi-category extraction
+    category_patterns = {
+        "total_due": [
+            r"Total desta fatura\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"Total da fatura\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"TOTAL A PAGAR\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"= Total desta fatura\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"TOTAL\s*[=R\$\s]*([\d\.]+,\d{2})",
+        ],
+        "domestic_purchases": [
+            r"Compras nacionais\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"COMPRAS NACIONAIS\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"Lançamentos nacionais\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"LANÇAMENTOS NACIONAIS\s*[=R\$\s]*([\d\.]+,\d{2})",
+        ],
+        "international_purchases": [
+            r"Compras internacionais\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"COMPRAS INTERNACIONAIS\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"Lançamentos internacionais\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"LANÇAMENTOS INTERNACIONAIS\s*[=R\$\s]*([\d\.]+,\d{2})",
+        ],
+        "payments": [
+            r"Pagamentos efetuados\s*[=R\$\s]*(-?[\d\.]+,\d{2})",
+            r"PAGAMENTOS EFETUADOS\s*[=R\$\s]*(-?[\d\.]+,\d{2})",
+            r"Pagamentos\s*[=R\$\s]*(-?[\d\.]+,\d{2})",
+        ],
+        "fees_interest": [
+            r"Encargos e juros\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"ENCARGOS E JUROS\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"Juros\s*[=R\$\s]*([\d\.]+,\d{2})",
+            r"IOF\s*[=R\$\s]*([\d\.]+,\d{2})",
+        ],
+        "credits_adjustments": [
+            r"Créditos.*?\s*[=R\$\s]*(-?[\d\.]+,\d{2})",
+            r"CRÉDITOS.*?\s*[=R\$\s]*(-?[\d\.]+,\d{2})",
+            r"Ajustes\s*[=R\$\s]*(-?[\d\.]+,\d{2})",
+            r"Estornos\s*[=R\$\s]*(-?[\d\.]+,\d{2})",
+        ]
+    }
+    
+    totals: Dict[str, Decimal] = {}
+    
+    for category, patterns in category_patterns.items():
+        for pattern in patterns:
+            match = re.search(pattern, text, re.IGNORECASE)
+            if match:
+                val_str = match.group(1).replace(".", "").replace(",", ".")
+                totals[category] = Decimal(val_str)
+                break  # Use first match for each category
+    
+    return totals
+
+
 def calculate_csv_total(rows: Iterable[Dict]) -> Decimal:
     """Sum ``amount_brl`` values for *rows*."""
     total = Decimal("0.00")
@@ -55,6 +135,99 @@ def calculate_csv_total(rows: Iterable[Dict]) -> Decimal:
     return total
 
 
+def calculate_category_totals(rows: Iterable[Dict]) -> Dict[str, Decimal]:
+    """Calculate totals by transaction category for fitness scoring."""
+    totals = {
+        "domestic": Decimal("0.00"),
+        "international": Decimal("0.00"), 
+        "payments": Decimal("0.00"),
+        "services": Decimal("0.00"),
+        "adjustments": Decimal("0.00"),
+        "total": Decimal("0.00")
+    }
+    
+    for row in rows:
+        amount = Decimal(row.get("amount_brl", "0"))
+        category = row.get("category", "")
+        
+        # Total sum
+        totals["total"] += amount
+        
+        # Category classification
+        if category in DOMESTIC_CATEGORIES:
+            totals["domestic"] += amount
+        elif category in INTERNATIONAL_CATEGORIES:
+            totals["international"] += amount
+        elif category == "PAGAMENTO":
+            totals["payments"] += amount
+        elif category in SERVICE_CATEGORIES:
+            totals["services"] += amount
+        elif category == "AJUSTE":
+            totals["adjustments"] += amount
+    
+    return totals
+
+
+def calculate_fitness_score(pdf_path: Path, rows: Iterable[Dict]) -> Dict[str, float]:
+    """Calculate multi-dimensional fitness score for self-supervised training."""
+    try:
+        # Extract PDF statement totals
+        statement_totals = extract_statement_totals(pdf_path)
+        
+        # Calculate CSV category totals
+        csv_totals = calculate_category_totals(rows)
+        
+        # Calculate deltas for each category
+        deltas = {}
+        
+        # Total due comparison
+        if "total_due" in statement_totals:
+            deltas["total"] = abs(csv_totals["total"] - statement_totals["total_due"])
+        
+        # Domestic purchases comparison
+        if "domestic_purchases" in statement_totals:
+            deltas["domestic"] = abs(csv_totals["domestic"] - statement_totals["domestic_purchases"])
+        
+        # International purchases comparison  
+        if "international_purchases" in statement_totals:
+            deltas["international"] = abs(csv_totals["international"] - statement_totals["international_purchases"])
+        
+        # Payments comparison
+        if "payments" in statement_totals:
+            deltas["payments"] = abs(csv_totals["payments"] - statement_totals["payments"])
+        
+        # Convert to fitness scores (negative delta = higher is better)
+        fitness = {category: -float(delta) for category, delta in deltas.items()}
+        
+        # Overall fitness (sum of all category fitness)
+        fitness["overall"] = sum(fitness.values())
+        
+        # Add percentage accuracy for each category
+        accuracy = {}
+        for category, delta in deltas.items():
+            if category in statement_totals:
+                pdf_total = statement_totals.get(category.replace("_", "_"), 0)
+                if pdf_total > 0:
+                    accuracy[f"{category}_accuracy"] = float((1 - delta / pdf_total) * 100)
+                else:
+                    accuracy[f"{category}_accuracy"] = 100.0 if delta == 0 else 0.0
+        
+        fitness.update(accuracy)
+        
+        return fitness
+        
+    except Exception as e:
+        # Return zero fitness if extraction fails
+        return {
+            "total": 0.0,
+            "domestic": 0.0, 
+            "international": 0.0,
+            "payments": 0.0,
+            "overall": 0.0,
+            "error": str(e)
+        }
+
+
 def find_duplicates(rows: Iterable[Dict]) -> List[Tuple[str, int]]:
     """Identify duplicate transactions by ``ledger_hash``."""
     seen: Dict[str, int] = {}

diff --git a/scripts/ai_focused_accuracy.py b/scripts/ai_focused_accuracy.py
index 1234567..abcdefg 100644
--- a/scripts/ai_focused_accuracy.py
+++ b/scripts/ai_focused_accuracy.py
@@ -18,7 +18,12 @@ sys.path.insert(0, str(ROOT / "src"))
 
 from statement_refinery.pdf_to_csv import parse_pdf
-from statement_refinery.validation import extract_total_from_pdf, calculate_csv_total
+from statement_refinery.validation import (
+    extract_total_from_pdf, 
+    calculate_csv_total,
+    extract_statement_totals,
+    calculate_fitness_score
+)
 
 DATA_DIR = ROOT / "tests" / "data"
 
@@ -30,11 +35,13 @@ VERIFIED_BASELINES = {
 
 
 def analyze_pdf_for_ai(pdf_path: Path) -> dict:
-    """Analyze a single PDF and return AI-focused results."""
+    """Analyze a single PDF and return AI-focused results with multi-category fitness scoring."""
 
     result = {
         "pdf_name": pdf_path.name,
         "is_verified_baseline": pdf_path.name in VERIFIED_BASELINES,
         "parsing_status": "unknown",
         "financial_accuracy": None,
+        "fitness_scores": None,
+        "category_breakdown": None,
+        "improvement_targets": [],
         "diagnostic_summary": "",
     }
@@ -44,7 +51,7 @@ def analyze_pdf_for_ai(pdf_path: Path) -> dict:
         rows = parse_pdf(pdf_path, use_golden_if_available=False)
         parsed_total = calculate_csv_total(rows)
 
-        # Get PDF total for comparison
+        # Legacy single-total comparison for compatibility
         try:
             pdf_total = extract_total_from_pdf(pdf_path)
             delta = abs(parsed_total - pdf_total)
@@ -56,15 +63,51 @@ def analyze_pdf_for_ai(pdf_path: Path) -> dict:
                 "accuracy_percentage": accuracy * 100,
                 "status": "GOOD" if accuracy > 0.95 else "NEEDS_IMPROVEMENT",
             }
+        except Exception as e:
+            result["financial_accuracy"] = {
+                "error": str(e),
+                "status": "PDF_TOTAL_UNAVAILABLE"
+            }
 
-            if accuracy < 0.95:
-                result["parsing_status"] = "NEEDS_IMPROVEMENT"
-                result["diagnostic_summary"] = (
-                    f"Missing {delta:.2f} BRL ({(1 - accuracy) * 100:.1f}% of total)"
-                )
-            else:
-                result["parsing_status"] = "GOOD"
+        # NEW: Multi-category fitness scoring
+        fitness_scores = calculate_fitness_score(pdf_path, rows)
+        result["fitness_scores"] = fitness_scores
 
+        # Extract category breakdown from PDF
+        try:
+            statement_totals = extract_statement_totals(pdf_path)
+            result["category_breakdown"] = {
+                "pdf_totals": {k: float(v) for k, v in statement_totals.items()},
+                "fitness_deltas": {k: -v for k, v in fitness_scores.items() if not k.endswith("_accuracy") and k != "error"}
+            }
+        except Exception as e:
+            result["category_breakdown"] = {"error": str(e)}
+
+        # Identify specific improvement targets
+        improvement_targets = []
+        for category, score in fitness_scores.items():
+            if category.endswith("_accuracy") and isinstance(score, (int, float)):
+                if score < 95.0:  # Less than 95% accuracy
+                    improvement_targets.append({
+                        "category": category.replace("_accuracy", ""),
+                        "accuracy": score,
+                        "priority": "HIGH" if score < 80.0 else "MEDIUM"
+                    })
+        
+        result["improvement_targets"] = improvement_targets
+
+        # Overall status determination
+        overall_fitness = fitness_scores.get("overall", 0)
+        if overall_fitness > -0.5:  # Within 0.50 BRL total error
+            result["parsing_status"] = "GOOD"
+            result["diagnostic_summary"] = f"High accuracy (fitness: {overall_fitness:.2f})"
+        elif overall_fitness > -5.0:  # Within 5.00 BRL total error
+            result["parsing_status"] = "NEEDS_IMPROVEMENT"
+            worst_category = min(improvement_targets, key=lambda x: x["accuracy"]) if improvement_targets else None
+            if worst_category:
+                result["diagnostic_summary"] = f"Focus on {worst_category['category']} patterns ({worst_category['accuracy']:.1f}% accuracy)"
+            else:
+                result["diagnostic_summary"] = f"Minor parsing gaps (fitness: {overall_fitness:.2f})"
+        else:
+            result["parsing_status"] = "MAJOR_ISSUES"
+            result["diagnostic_summary"] = f"Significant parsing failures (fitness: {overall_fitness:.2f})"
+
     except Exception as e:
         result["parsing_status"] = "PARSING_FAILED"
         result["diagnostic_summary"] = f"Parser error: {e}"
@@ -100,12 +143,27 @@ def main():
             else:
                 print(f"   ❌ BROKEN BASELINE: {result['diagnostic_summary']}")
         else:
             print(f"🎯 TARGET: {pdf.name}")
-            if result["financial_accuracy"]:
+            
+            # Show fitness-based analysis
+            if result["fitness_scores"]:
+                overall_fitness = result["fitness_scores"].get("overall", 0)
+                print(f"   🧬 Overall Fitness: {overall_fitness:.2f}")
+                
+                # Show category-specific issues
+                if result["improvement_targets"]:
+                    for target in result["improvement_targets"]:
+                        priority_emoji = "🔥" if target["priority"] == "HIGH" else "⚠️"
+                        print(f"   {priority_emoji} {target['category']}: {target['accuracy']:.1f}% accuracy")
+                else:
+                    print(f"   ✅ All categories > 95% accuracy")
+            
+            # Legacy accuracy display for compatibility
+            if result["financial_accuracy"] and "accuracy_percentage" in result["financial_accuracy"]:
                 acc = result["financial_accuracy"]["accuracy_percentage"]
-                print(f"   📊 Accuracy: {acc:.1f}% - {result['diagnostic_summary']}")
-            else:
-                print(f"   ❓ {result['diagnostic_summary']}")
+                print(f"   📊 Legacy Accuracy: {acc:.1f}%")
+            
+            print(f"   📝 {result['diagnostic_summary']}")
 
-            if result["parsing_status"] == "NEEDS_IMPROVEMENT":
+            if result["parsing_status"] in ["NEEDS_IMPROVEMENT", "MAJOR_ISSUES"]:
                 training_targets.append(result)
 
     print("\n🎯 AI TRAINING SUMMARY")
@@ -115,18 +173,26 @@ def main():
 
     if training_targets:
         print("\n📝 PRIORITY TARGETS FOR AI IMPROVEMENT:")
+        
+        # Sort by overall fitness (worst first)
         for target in sorted(
             training_targets,
-            key=lambda x: (
-                x["financial_accuracy"]["accuracy_percentage"]
-                if x["financial_accuracy"]
-                else 0
-            ),
+            key=lambda x: x["fitness_scores"].get("overall", 0) if x["fitness_scores"] else 0
         ):
-            if target["financial_accuracy"]:
+            fitness = target["fitness_scores"].get("overall", 0) if target["fitness_scores"] else 0
+            print(f"   • {target['pdf_name']}: Overall Fitness {fitness:.2f}")
+            
+            # Show specific category targets
+            if target["improvement_targets"]:
+                for category_target in target["improvement_targets"]:
+                    priority_icon = "🔥" if category_target["priority"] == "HIGH" else "⚠️"
+                    print(f"     {priority_icon} {category_target['category']}: {category_target['accuracy']:.1f}% accuracy")
+            
+            # Legacy accuracy for reference
+            if target["financial_accuracy"] and "accuracy_percentage" in target["financial_accuracy"]:
                 acc = target["financial_accuracy"]["accuracy_percentage"]
-                delta = target["financial_accuracy"]["delta"]
-                print(
-                    f"   • {target['pdf_name']}: {acc:.1f}% (missing {delta:.2f} BRL)"
-                )
+                delta = target["financial_accuracy"].get("delta", 0)
+                print(f"     📊 Legacy: {acc:.1f}% (Δ {delta:.2f} BRL)")
+            
+            print()  # Empty line for readability
 
     # Save AI-focused results

diff --git a/.github/tools/evolve.py b/.github/tools/evolve.py
index 1234567..abcdefg 100644
--- a/.github/tools/evolve.py
+++ b/.github/tools/evolve.py
@@ -70,6 +70,8 @@ def collect_context() -> dict:
         "invariant_scores": {},
         "hard_golden_status": {},
         "ai_focused_accuracy": {},
+        "fitness_analysis": {},
+        "category_targets": [],
     }
 
     # Get test output
@@ -104,7 +106,38 @@ def collect_context() -> dict:
     ai_accuracy_file = DIAGNOSTICS / "ai_focused_accuracy.json"
     if ai_accuracy_file.exists():
         try:
-            context["ai_focused_accuracy"] = json.loads(ai_accuracy_file.read_text())
+            ai_data = json.loads(ai_accuracy_file.read_text())
+            context["ai_focused_accuracy"] = ai_data
+            
+            # Extract fitness-based analysis for targeted improvements
+            if "detailed_results" in ai_data:
+                fitness_summary = {}
+                category_targets = []
+                
+                for result in ai_data["detailed_results"]:
+                    pdf_name = result.get("pdf_name", "unknown")
+                    fitness_scores = result.get("fitness_scores", {})
+                    improvement_targets = result.get("improvement_targets", [])
+                    
+                    if fitness_scores:
+                        fitness_summary[pdf_name] = {
+                            "overall_fitness": fitness_scores.get("overall", 0),
+                            "worst_categories": improvement_targets[:3],  # Top 3 worst
+                            "status": result.get("parsing_status", "unknown")
+                        }
+                    
+                    # Collect all category targets for AI focus
+                    for target in improvement_targets:
+                        category_targets.append({
+                            "pdf": pdf_name,
+                            "category": target["category"],
+                            "accuracy": target["accuracy"],
+                            "priority": target["priority"]
+                        })
+                
+                context["fitness_analysis"] = fitness_summary
+                context["category_targets"] = sorted(category_targets, key=lambda x: x["accuracy"])
+                
         except Exception:
             context["errors"].append("Failed to read AI-focused accuracy")
 
@@ -522,44 +555,74 @@ def get_current_invariant_score() -> float:
 def run_single_iteration(context: dict, iteration: int, current_score: float) -> bool:
     """Run a single iteration of AI improvement."""
     print(f"🧠 Running AI analysis for iteration {iteration}...")
 
-    # Prepare enhanced prompt with new training signals
+    # Prepare enhanced prompt with category-targeted training signals
     prompt = [
         f"You are an AI parser improvement specialist (ITERATION {iteration}/{MAX_ITERATIONS}). "
-        f"Using Hard Goldens + Soft Invariants strategy to achieve 99% financial accuracy. "
+        f"Using Self-Supervised Multi-Category Training to achieve 99% financial accuracy. "
         f"Current score: {current_score:.1f}% → Target: 99.0%",
         "",
-        "=== TRAINING SIGNAL ANALYSIS ===",
+        "=== SELF-SUPERVISED TRAINING ANALYSIS ===",
         "",
         "HARD GOLDENS (Must maintain 100% exact match):",
         "- Itau_2024-10.pdf: MUST remain exactly matching golden CSV",
         "- Itau_2025-05.pdf: MUST remain exactly matching golden CSV",
         "",
-        "INVARIANT SCORES (Primary improvement target):",
+        "FITNESS-BASED ANALYSIS (Multi-category self-supervision):",
+        json.dumps(context["fitness_analysis"], indent=2),
+        "",
+        "PRIORITY CATEGORY TARGETS (Worst accuracy first):",
+        json.dumps(context["category_targets"][:10], indent=2),  # Top 10 worst categories
+        "",
+        "INVARIANT SCORES (Secondary validation):",
         json.dumps(context["invariant_scores"], indent=2),
         "",
-        "FINANCIAL ACCURACY BY PDF:",
-        json.dumps(context["ai_focused_accuracy"], indent=2),
+        "=== TARGETED IMPROVEMENT STRATEGY ===",
         "",
-        "=== IMPROVEMENT FOCUS ===",
-        f"Priority: Bridge the gap from {current_score:.1f}% to 99.0% financial accuracy",
-        "Method: Enhance regex patterns in pdf_to_csv.py to capture missing transactions",
-        f"Iteration Strategy: Progressive improvement over {MAX_ITERATIONS} iterations",
+        f"Iteration {iteration} Focus:",
+    ]
+    
+    # Add category-specific focus for this iteration
+    if context["category_targets"]:
+        worst_categories = {}
+        for target in context["category_targets"][:5]:  # Focus on 5 worst
+            category = target["category"]
+            if category not in worst_categories:
+                worst_categories[category] = []
+            worst_categories[category].append(f"{target['pdf']} ({target['accuracy']:.1f}%)")
+        
+        prompt.extend([
+            "",
+            "SPECIFIC CATEGORIES TO IMPROVE:",
+            json.dumps(worst_categories, indent=2),
+            "",
+            "Pattern Enhancement Priority:",
+            "1. Add regex patterns for the worst-performing categories above",
+            "2. Focus on transaction types that cause fitness score penalties",
+            "3. Ensure PDF statement totals match parsed CSV totals by category",
+            "4. Maintain backward compatibility with hard golden CSVs",
+        ])
+    else:
+        prompt.extend([
+            "No specific category targets identified - focus on overall accuracy",
+        ])
+    
+    prompt.extend([
         "",
-        "=== Traditional Metrics (Reference Only) ===",
+        "=== CONTEXT FOR REFERENCE ===",
         "",
         "Test Output:",
-        context["tests"][:1000],  # Truncate for context
+        context["tests"][:800],  # Truncate for context
         "",
         "Lint Output:",
-        context["lint"][:500],  # Truncate for context
+        context["lint"][:400],  # Truncate for context
         "",
         "Legacy Accuracy:",
         json.dumps(context["accuracy"], indent=2),
         "",
-        "=== Code Files to Improve ===",
-    ]
+        "=== CODE FILES TO IMPROVE ===",
+    ])
 
     for file in context["files"]:
         prompt.extend(
@@ -572,31 +635,40 @@ def run_single_iteration(context: dict, iteration: int, current_score: float) -
 
     prompt.extend(
         [
-            f"IMPROVEMENT STRATEGY (Iteration {iteration}):",
             "",
+            f"SELF-SUPERVISED IMPROVEMENT STRATEGY (Iteration {iteration}):",
+            "",
+            "CORE PRINCIPLE: Every PDF contains its own ground truth in the statement summary!",
+            "",
             "1. PRESERVE Hard Goldens: Ensure Itau_2024-10.pdf and Itau_2025-05.pdf maintain exact CSV output",
-            "2. TARGET 99% Financial Accuracy: Focus on PDFs with worst accuracy scores",
-            "3. ENHANCE Regex Patterns: Add new patterns to capture missing transaction types",
-            "4. VALIDATE Against PDF Totals: Ensure PDF total matches parsed CSV total",
+            "2. TARGET Category-Specific Patterns: Focus on worst-performing categories from fitness analysis",
+            "3. ENHANCE Multi-Category Recognition: Add patterns for domestic/international/payment transactions",
+            "4. VALIDATE Against PDF Category Totals: Ensure each category sum matches PDF summary",
             "",
-            "SPECIFIC TARGETS (from financial accuracy analysis):",
-            "- Worst performers need new transaction patterns",
-            "- Missing amounts indicate unparsed transaction lines",
-            "- Focus on transaction formats not captured by current regex",
+            "CATEGORY-TARGETED APPROACH:",
+            "- 'domestic': Patterns for SUPERMERCADO, FARMÁCIA, RESTAURANTE, POSTO, etc.",
+            "- 'international': Patterns for FX transactions and international purchases", 
+            "- 'payments': Patterns for PAGAMENTO transactions with 7117 codes",
+            "- 'services': Patterns for SERVIÇOS, ENCARGOS, fees and interest",
             "",
+            "FITNESS OPTIMIZATION:",
+            "- Each regex improvement should reduce fitness penalties (negative deltas)",
+            "- Focus on categories with lowest accuracy percentages",
+            "- Test changes against PDF statement summary totals",
+            "",
             "Please suggest fixes in the following format:",
             "FILE: path/to/file.py",
             "```python",
             "complete fixed file content",
             "```",
             "",
             "PRIORITY ORDER:",
-            "1. Add missing regex patterns for unparsed transactions",
-            "2. Fix financial total extraction patterns",
-            "3. Improve transaction categorization",
-            "4. Maintain hard golden compatibility",
+            "1. Add category-specific regex patterns for worst-performing categories",
+            "2. Enhance transaction classification to match PDF summary categories",
+            "3. Improve amount extraction for better financial total matching",
+            "4. Maintain hard golden compatibility (critical!)",
             "5. Address any lint/test issues",
         ]
     )

diff --git a/tests/test_invariants.py b/tests/test_invariants.py
index 1234567..abcdefg 100644
--- a/tests/test_invariants.py
+++ b/tests/test_invariants.py
@@ -18,7 +18,11 @@ import pytest
 
 from statement_refinery.pdf_to_csv import parse_pdf
-from statement_refinery.validation import extract_total_from_pdf
+from statement_refinery.validation import (
+    extract_total_from_pdf,
+    calculate_fitness_score,
+    extract_statement_totals
+)
 
 
 class InvariantResults:
@@ -27,6 +31,7 @@ class InvariantResults:
     def __init__(self):
         self.results: Dict[str, Dict[str, bool]] = {}
         self.scores: Dict[str, float] = {}
+        self.fitness_scores: Dict[str, Dict[str, float]] = {}
 
     def record(self, pdf_name: str, invariant_name: str, passed: bool):
         """Record an invariant test result."""
@@ -34,6 +39,10 @@ class InvariantResults:
             self.results[pdf_name] = {}
         self.results[pdf_name][invariant_name] = passed
 
+    def record_fitness(self, pdf_name: str, fitness_data: Dict[str, float]):
+        """Record fitness scores for multi-category analysis."""
+        self.fitness_scores[pdf_name] = fitness_data
+
     def calculate_scores(self) -> Dict[str, float]:
         """Calculate percentage scores for each PDF."""
         for pdf_name, invariants in self.results.items():
@@ -55,7 +64,39 @@ class InvariantResults:
         return sum(self.scores.values()) / len(self.scores) if self.scores else 0
 
     def save_report(self, output_path: Path):
-        """Save detailed report to JSON file."""
+        """Save detailed report to JSON file with fitness scores."""
         self.calculate_scores()
+        
+        # Calculate fitness-based metrics
+        overall_fitness = 0.0
+        fitness_count = 0
+        category_performance = {}
+        
+        for pdf_name, fitness_data in self.fitness_scores.items():
+            if "overall" in fitness_data:
+                overall_fitness += fitness_data["overall"]
+                fitness_count += 1
+            
+            # Track category performance
+            for key, value in fitness_data.items():
+                if key.endswith("_accuracy") and isinstance(value, (int, float)):
+                    category = key.replace("_accuracy", "")
+                    if category not in category_performance:
+                        category_performance[category] = []
+                    category_performance[category].append(value)
+        
+        avg_fitness = overall_fitness / fitness_count if fitness_count > 0 else 0.0
+        avg_category_scores = {}
+        for category, scores in category_performance.items():
+            avg_category_scores[category] = sum(scores) / len(scores) if scores else 0.0
+        
         report = {
             "overall_score": self.overall_score(),
             "pdf_scores": self.scores,
             "detailed_results": self.results,
+            "fitness_analysis": {
+                "average_overall_fitness": avg_fitness,
+                "pdf_fitness_scores": self.fitness_scores,
+                "category_performance": avg_category_scores,
+                "worst_categories": sorted(avg_category_scores.items(), key=lambda x: x[1])[:5]
+            },
             "summary": {
                 "total_pdfs": len(self.results),
                 "avg_score": self.overall_score(),
+                "avg_fitness": avg_fitness,
                 "passing_pdfs": len([s for s in self.scores.values() if s >= 95.0]),
                 "failing_pdfs": len([s for s in self.scores.values() if s < 70.0]),
+                "high_fitness_pdfs": len([f for f in self.fitness_scores.values() if f.get("overall", -999) > -1.0]),
             },
         }
         output_path.write_text(json.dumps(report, indent=2))
@@ -168,12 +209,33 @@ def test_invariant_financial_totals(request):
             if csv_path.exists():
                 with open(csv_path, "r", encoding="utf-8") as f:
                     reader = csv.DictReader(f, delimiter=";")
                     csv_total = sum(Decimal(row["amount_brl"]) for row in reader)
+                    rows = list(csv.DictReader(open(csv_path, "r", encoding="utf-8"), delimiter=";"))
             else:
                 # Parse directly if CSV doesn't exist
                 rows = parse_pdf(pdf_path, use_golden_if_available=False)
                 csv_total = sum(Decimal(str(row["amount_brl"])) for row in rows)
 
             # Check if totals match within tolerance
             delta = abs(pdf_total - csv_total)
             passed = delta <= Decimal("0.01")
             invariant_results.record(pdf_name, "financial_total", passed)
+
+            # NEW: Calculate and record fitness scores
+            try:
+                fitness_data = calculate_fitness_score(pdf_path, rows)
+                invariant_results.record_fitness(pdf_name, fitness_data)
+                
+                overall_fitness = fitness_data.get("overall", 0)
+                print(f"🧬 {pdf_name}: Fitness {overall_fitness:.2f}")
+                
+                # Show category breakdowns for failing cases
+                if overall_fitness < -1.0:  # Poor fitness
+                    for key, value in fitness_data.items():
+                        if key.endswith("_accuracy") and isinstance(value, (int, float)) and value < 95.0:
+                            category = key.replace("_accuracy", "")
+                            print(f"   📊 {category}: {value:.1f}% accuracy")
+            except Exception as e:
+                print(f"⚠️  {pdf_name}: Fitness calculation failed - {e}")
 
             if not passed:
                 print(f"❌ {pdf_name}: PDF {pdf_total} vs CSV {csv_total} (Δ {delta})")
@@ -458,11 +520,24 @@ def save_invariant_report(request):
 
     invariant_results.save_report(output_dir / "invariant_scores.json")
 
-    # Print summary
+    # Print summary with fitness analysis
     overall = invariant_results.overall_score()
     print("\n📊 INVARIANT SUMMARY")
     print(f"Overall Score: {overall:.1f}%")
+    
+    # Calculate fitness summary
+    if invariant_results.fitness_scores:
+        avg_fitness = sum(f.get("overall", 0) for f in invariant_results.fitness_scores.values()) / len(invariant_results.fitness_scores)
+        print(f"Average Fitness: {avg_fitness:.2f}")
+        
+        # Count high-fitness PDFs
+        high_fitness_count = len([f for f in invariant_results.fitness_scores.values() if f.get("overall", -999) > -1.0])
+        print(f"High Fitness PDFs: {high_fitness_count}/{len(invariant_results.fitness_scores)}")
+    
     print("Individual Scores:")
-
     for pdf_name, score in sorted(invariant_results.scores.items()):
         status = "✅" if score >= 95 else "⚠️" if score >= 70 else "❌"
-        print(f"  {status} {pdf_name}: {score:.1f}%")
+        fitness_info = ""
+        if pdf_name in invariant_results.fitness_scores:
+            fitness = invariant_results.fitness_scores[pdf_name].get("overall", 0)
+            fitness_info = f" (fitness: {fitness:.2f})"
+        print(f"  {status} {pdf_name}: {score:.1f}%{fitness_info}")
