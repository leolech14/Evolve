import io
import contextlib
import argparse
from pathlib import Path
import difflib
import importlib.util
import json
import statistics
import sys, os  # noqa: E401,F401
import csv
from decimal import Decimal
import re

ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT / "src"))
HAS_PDFPLUMBER = importlib.util.find_spec("pdfplumber") is not None
if not HAS_PDFPLUMBER:
    print("pdfplumber not installed; using text fallback")

from statement_refinery import pdf_to_csv  # noqa: E402

# Golden CSVs checked into ``tests/data`` are generated by running
# ``pdf_to_csv`` on each statement PDF with ``--out``.  When a new PDF is added
# without a matching golden file this script fails, ensuring CI stays in sync.

DATA_DIR = ROOT / "tests" / "data"


def extract_total_from_pdf(pdf_path: Path) -> Decimal:
    """Return the total amount printed in the PDF or snapshot text."""
    txt_path = pdf_path.with_suffix(".txt")
    if txt_path.exists():
        text = txt_path.read_text()
    elif HAS_PDFPLUMBER:
        import pdfplumber

        with pdfplumber.open(str(pdf_path)) as pdf:
            text = "\n".join(page.extract_text() or "" for page in pdf.pages)
        txt_path.write_text(text)
    else:
        raise FileNotFoundError(f"No text fallback for {pdf_path.name}")

    patterns = [
        r"Totaldestafatura\s*[=R\$\s]*([\d\.]+,\d{2})",
        r"Total\s*desta\s*fatura\s*[=R\$\s]*([\d\.]+,\d{2})",
        r"Totaldafatura\s*[=R\$\s]*([\d\.]+,\d{2})",
        r"Total\s*da\s*fatura\s*[=R\$\s]*([\d\.]+,\d{2})",
        r"Valor\s*total\s*a\s*pagar\s*[=R\$\s]*([\d\.]+,\d{2})",
        r"Valortotalapagar\s*[=R\$\s]*([\d\.]+,\d{2})",
        r"Total\s*a\s*pagar\s*[=R\$\s]*([\d\.]+,\d{2})",
        r"Totalapagar\s*[=R\$\s]*([\d\.]+,\d{2})",
        r"TOTAL\s*[=R\$\s]*([\d\.]+,\d{2})",
        r"Valor\s*Total\s*[=R\$\s]*([\d\.]+,\d{2})",
        r"Saldo\s*Total\s*[=R\$\s]*([\d\.]+,\d{2})",
        r"Total\s*[=R\$\s]*([\d\.]+,\d{2})",
    ]
    for pattern in patterns:
        match = re.search(pattern, text)

        if match:
            val = match.group(1).replace(".", "").replace(",", ".")
            return Decimal(val)
    raise ValueError(f"Could not find total in {pdf_path.name}")



def compare(pdf_path: Path, out_dir: Path | None = None) -> tuple[bool, float]:
    """Run pdf_to_csv on *pdf_path* and compare to its golden CSV.

    Returns ``(mismatch, percentage)``.
    """
    print(f"\n=== {pdf_path.name} ===")
    buf = io.StringIO()
    args = [str(pdf_path)]
    out_path = None
    if out_dir is not None:
        out_dir.mkdir(parents=True, exist_ok=True)
        out_path = out_dir / f"{pdf_path.stem}.csv"
        args += ["--out", str(out_path)]
    with contextlib.redirect_stdout(buf):
        if HAS_PDFPLUMBER:
            pdf_to_csv.main(args)
            txt_file = pdf_path.with_suffix(".txt")
            if not txt_file.exists():
                lines = list(pdf_to_csv.iter_pdf_lines(pdf_path))
                txt_file.write_text("\n".join(lines))
        else:
            txt = pdf_path.with_suffix(".txt")
            if not txt.exists():
                print("Fallback text file missing. Skipping.")
                return False, 0.0
            lines = txt.read_text().splitlines()
            rows = pdf_to_csv.parse_lines(iter(lines))
            pdf_to_csv.write_csv(rows, buf)
    if out_path is not None:
        output_lines = out_path.read_text().splitlines()
    else:
        output_lines = buf.getvalue().splitlines()

    golden = pdf_path.with_name(f"golden_{pdf_path.stem.split('_')[-1]}.csv")
    if not golden.exists():
        raise FileNotFoundError(f"Missing golden CSV for {pdf_path.name}")

    golden_lines = golden.read_text().splitlines()
    diff = difflib.unified_diff(
        golden_lines,
        output_lines,
        fromfile=golden.name,
        tofile="generated",
        lineterm="",
    )
    diff_list = list(diff)
    mismatch = bool(diff_list)
    if mismatch:
        print("\n".join(diff_list))
    else:
        print("Output matches golden file exactly.")

    matcher = difflib.SequenceMatcher(None, golden_lines, output_lines)
    pct = matcher.ratio() * 100
    print(f"Match percentage: {pct:.2f}%")

    reader = csv.DictReader(output_lines, delimiter=";")
    csv_total = sum(Decimal(r["amount_brl"]) for r in reader)

    try:
        pdf_total = extract_total_from_pdf(pdf_path)
        if abs(csv_total - pdf_total) > Decimal("0.01"):
            print(f"Total mismatch: CSV {csv_total} vs PDF {pdf_total}")
            mismatch = True
    except Exception as exc:
        print(f"Could not verify total: {exc}")

    return mismatch, pct


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--threshold",
        type=float,
        default=99.0,
        help="fail if average match percentage is below this value",
    )
    parser.add_argument(
        "--summary-file",
        default="accuracy_summary.json",
        help="write JSON summary to this file",
    )
    parser.add_argument(
        "--csv-dir",
        default=None,
        help="directory to write generated CSV files",
    )
    args = parser.parse_args()

    pdfs = sorted(DATA_DIR.glob("[iI]tau_*.pdf"))
    if not pdfs:
        print("No PDFs found in tests/data.")
        return

    mismatched = False
    percentages = []
    total = len(pdfs)
    for idx, pdf in enumerate(pdfs, 1):
        print(f"\nProcessing {idx}/{total}: {pdf.name}")
        try:
            mis, pct = compare(pdf, Path(args.csv_dir) if args.csv_dir else None)
        except FileNotFoundError as exc:
            print(exc)
            mismatched = True
            continue
        percentages.append(pct)
        if mis:
            mismatched = True

    avg = statistics.mean(percentages) if percentages else 0.0
    print(f"Average match across PDFs: {avg:.2f}%")
    if avg < args.threshold:
        print(f"Accuracy {avg:.2f}% below threshold {args.threshold}%")
        mismatched = True

    summary = {"pdf_count": len(pdfs), "average": avg}
    Path(args.summary_file).write_text(json.dumps(summary))

    if mismatched:
        raise SystemExit("mismatched parser output or low accuracy")

    print("All PDF checks passed \N{PARTY POPPER}")


if __name__ == "__main__":
    main()
